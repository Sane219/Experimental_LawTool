"""
Integration tests for output and export functionality.
Tests the complete workflow of summary output, copy-to-clipboard formatting,
PDF export generation, and additional export options.
"""

import pytest
import io
from datetime import datetime
from unittest.mock import Mock, patch
from reportlab.lib.pagesizes import A4

from src.models.data_models import SummaryResult
from src.services.output_handler import OutputHandler


class TestOutputExportIntegration:
    """Integration tests for output and export functionality."""
    
    @pytest.fixture
    def output_handler(self):
        """Create an OutputHandler instance for testing."""
        return OutputHandler()
    
    @pytest.fixture
    def sample_summary_result(self):
        """Create a sample SummaryResult for testing."""
        return SummaryResult(
            original_filename="test_contract.pdf",
            summary_text="This is a comprehensive legal contract between Party A and Party B. The contract outlines the terms and conditions for service delivery, including payment schedules, deliverables, and termination clauses. Key obligations include monthly reporting requirements and compliance with industry standards.",
            processing_time=2.5,
            word_count=45,
            confidence_score=0.87,
            generated_at=datetime(2024, 1, 15, 14, 30, 0)
        )
    
    def test_clipboard_formatting_workflow(self, output_handler, sample_summary_result):
        """Test the complete clipboard formatting workflow."""
        # Format summary for clipboard
        clipboard_text = output_handler.format_summary_for_clipboard(sample_summary_result)
        
        # Verify the formatted text contains all required elements
        assert "LEGAL DOCUMENT SUMMARY" in clipboard_text
        assert "test_contract.pdf" in clipboard_text
        assert "2024-01-15 14:30:00" in clipboard_text
        assert "Word Count: 45" in clipboard_text
        assert "Processing Time: 2.50 seconds" in clipboard_text
        assert "Confidence: 87.0%" in clipboard_text
        assert "SUMMARY:" in clipboard_text
        assert sample_summary_result.summary_text in clipboard_text
        assert "Generated by AI-Powered Legal Document Summarizer" in clipboard_text
        
        # Verify formatting structure
        lines = clipboard_text.split('\n')
        assert len(lines) > 10  # Should have multiple lines
        assert lines[0] == "LEGAL DOCUMENT SUMMARY"
        
        # Find summary section
        summary_index = next(i for i, line in enumerate(lines) if line == "SUMMARY:")
        assert summary_index > 0
        assert lines[summary_index + 1] == sample_summary_result.summary_text
    
    def test_pdf_export_generation_workflow(self, output_handler, sample_summary_result):
        """Test the complete PDF export generation workflow."""
        # Generate PDF
        pdf_buffer = output_handler.generate_pdf_export(sample_summary_result)
        
        # Verify PDF buffer is created
        assert isinstance(pdf_buffer, io.BytesIO)
        assert pdf_buffer.tell() == 0  # Buffer should be at start
        
        # Get PDF content
        pdf_content = pdf_buffer.getvalue()
        assert len(pdf_content) > 1000  # PDF should have substantial content
        
        # Verify PDF header
        assert pdf_content.startswith(b'%PDF-')
        
        # Verify PDF contains text content (basic check)
        # PDF content is compressed, so we just verify it's a valid PDF
        assert len(pdf_content) > 1000  # Should have substantial content
        
        # Test buffer can be read multiple times
        pdf_buffer.seek(0)
        second_read = pdf_buffer.getvalue()
        assert pdf_content == second_read
    
    def test_filename_generation_workflow(self, output_handler, sample_summary_result):
        """Test filename generation for different export types."""
        # Test PDF filename generation
        pdf_filename = output_handler.generate_filename(sample_summary_result, "pdf")
        assert pdf_filename.startswith("summary_test_contract_")
        assert pdf_filename.endswith(".pdf")
        assert "20240115_143000" in pdf_filename
        
        # Test text filename generation
        txt_filename = output_handler.generate_filename(sample_summary_result, "txt")
        assert txt_filename.endswith(".txt")
        assert "summary_test_contract_" in txt_filename
        
        # Test JSON filename generation
        json_filename = output_handler.generate_filename(sample_summary_result, "json")
        assert json_filename.endswith(".json")
        assert "summary_test_contract_" in json_filename
        
        # Test filename with special characters
        special_result = SummaryResult(
            original_filename="test file with spaces & symbols!.pdf",
            summary_text="Test summary",
            processing_time=1.0,
            word_count=10,
            confidence_score=0.9,
            generated_at=datetime(2024, 1, 15, 14, 30, 0)
        )
        
        safe_filename = output_handler.generate_filename(special_result, "pdf")
        assert "test_file_with_spaces" in safe_filename
        assert "symbols" in safe_filename
        assert safe_filename.endswith(".pdf")
    
    def test_json_export_workflow(self, output_handler, sample_summary_result):
        """Test JSON export generation workflow."""
        # Generate JSON export
        json_content = output_handler.create_json_export(sample_summary_result)
        
        # Verify JSON structure
        import json
        export_data = json.loads(json_content)
        
        # Verify all required fields are present
        required_fields = [
            "original_filename", "summary_text", "processing_time",
            "word_count", "confidence_score", "generated_at",
            "export_timestamp", "generator"
        ]
        
        for field in required_fields:
            assert field in export_data
        
        # Verify data accuracy
        assert export_data["original_filename"] == "test_contract.pdf"
        assert export_data["summary_text"] == sample_summary_result.summary_text
        assert export_data["processing_time"] == 2.5
        assert export_data["word_count"] == 45
        assert export_data["confidence_score"] == 0.87
        assert export_data["generated_at"] == "2024-01-15T14:30:00"
        assert export_data["generator"] == "AI-Powered Legal Document Summarizer"
        
        # Verify export timestamp is recent
        export_time = datetime.fromisoformat(export_data["export_timestamp"])
        time_diff = datetime.now() - export_time
        assert time_diff.total_seconds() < 5  # Should be very recent
    
    def test_multiple_export_formats_workflow(self, output_handler, sample_summary_result):
        """Test generating multiple export formats from the same summary."""
        # Generate all export formats
        clipboard_text = output_handler.format_summary_for_clipboard(sample_summary_result)
        pdf_buffer = output_handler.generate_pdf_export(sample_summary_result)
        json_content = output_handler.create_json_export(sample_summary_result)
        
        # Verify all formats contain the core summary content
        assert sample_summary_result.summary_text in clipboard_text
        
        # PDF content is compressed, so we just verify it's a valid PDF
        pdf_content = pdf_buffer.getvalue()
        assert len(pdf_content) > 1000  # Should have substantial content
        
        import json
        json_data = json.loads(json_content)
        assert json_data["summary_text"] == sample_summary_result.summary_text
        
        # Verify each format has its unique characteristics
        assert "LEGAL DOCUMENT SUMMARY" in clipboard_text  # Clipboard header
        assert b'%PDF-' in pdf_buffer.getvalue()  # PDF header
        assert "export_timestamp" in json_content  # JSON metadata
    
    def test_error_handling_in_export_workflow(self, output_handler):
        """Test error handling during export operations."""
        # Test with invalid summary result
        invalid_result = SummaryResult(
            original_filename="",  # Empty filename
            summary_text="",  # Empty summary
            processing_time=-1.0,  # Invalid processing time
            word_count=0,
            confidence_score=1.5,  # Invalid confidence score
            generated_at=datetime.now()
        )
        
        # Clipboard formatting should handle empty content gracefully
        clipboard_text = output_handler.format_summary_for_clipboard(invalid_result)
        assert "LEGAL DOCUMENT SUMMARY" in clipboard_text
        assert "Word Count: 0" in clipboard_text
        
        # PDF generation should handle empty content
        pdf_buffer = output_handler.generate_pdf_export(invalid_result)
        assert isinstance(pdf_buffer, io.BytesIO)
        assert len(pdf_buffer.getvalue()) > 0
        
        # JSON export should handle invalid values
        json_content = output_handler.create_json_export(invalid_result)
        import json
        json_data = json.loads(json_content)
        assert json_data["word_count"] == 0
        assert json_data["confidence_score"] == 1.5  # Should preserve the value
    
    def test_large_summary_export_workflow(self, output_handler):
        """Test export workflow with large summary content."""
        # Create a large summary result
        large_summary = "This is a very long legal document summary. " * 200  # ~8000 characters
        
        large_result = SummaryResult(
            original_filename="large_document.pdf",
            summary_text=large_summary,
            processing_time=15.7,
            word_count=1600,
            confidence_score=0.92,
            generated_at=datetime.now()
        )
        
        # Test clipboard formatting with large content
        clipboard_text = output_handler.format_summary_for_clipboard(large_result)
        assert len(clipboard_text) > 8000
        assert large_summary in clipboard_text
        
        # Test PDF generation with large content
        pdf_buffer = output_handler.generate_pdf_export(large_result)
        pdf_content = pdf_buffer.getvalue()
        assert len(pdf_content) > 3000  # Should be substantial PDF
        
        # Test JSON export with large content
        json_content = output_handler.create_json_export(large_result)
        import json
        json_data = json.loads(json_content)
        assert json_data["summary_text"] == large_summary
        assert json_data["word_count"] == 1600
    
    def test_special_characters_in_export_workflow(self, output_handler):
        """Test export workflow with special characters and unicode."""
        # Create summary with special characters
        special_summary = """
        This contract contains special characters: 
        • Bullet points with unicode
        § Legal section symbols
        © Copyright notices
        "Smart quotes" and 'apostrophes'
        Accented characters: café, naïve, résumé
        Mathematical symbols: ≥ ≤ ≠ ±
        Currency: $1,000.00 €500 £200
        """
        
        special_result = SummaryResult(
            original_filename="contract_with_unicode_§_symbols.pdf",
            summary_text=special_summary,
            processing_time=3.2,
            word_count=35,
            confidence_score=0.88,
            generated_at=datetime.now()
        )
        
        # Test clipboard formatting preserves special characters
        clipboard_text = output_handler.format_summary_for_clipboard(special_result)
        assert "•" in clipboard_text
        assert "§" in clipboard_text
        assert "©" in clipboard_text
        assert "café" in clipboard_text
        assert "$1,000.00" in clipboard_text
        
        # Test PDF generation handles special characters
        pdf_buffer = output_handler.generate_pdf_export(special_result)
        assert len(pdf_buffer.getvalue()) > 1000
        
        # Test JSON export preserves unicode
        json_content = output_handler.create_json_export(special_result)
        import json
        json_data = json.loads(json_content)
        assert "café" in json_data["summary_text"]
        assert "§" in json_data["summary_text"]
        
        # Test filename generation with special characters
        safe_filename = output_handler.generate_filename(special_result, "pdf")
        assert "contract_with_unicode" in safe_filename
        assert "symbols" in safe_filename
        assert safe_filename.endswith(".pdf")


class TestOutputExportStreamlitIntegration:
    """Integration tests for Streamlit app output and export features."""
    
    @pytest.fixture
    def mock_streamlit(self):
        """Mock Streamlit components for testing."""
        with patch('streamlit.success') as mock_success, \
             patch('streamlit.error') as mock_error, \
             patch('streamlit.download_button') as mock_download, \
             patch('streamlit.code') as mock_code, \
             patch('streamlit.expander') as mock_expander:
            
            yield {
                'success': mock_success,
                'error': mock_error,
                'download_button': mock_download,
                'code': mock_code,
                'expander': mock_expander
            }
    
    def test_streamlit_copy_functionality_integration(self, mock_streamlit, sample_summary_result):
        """Test integration of copy functionality with Streamlit interface."""
        from app import LegalDocumentSummarizerApp
        
        app = LegalDocumentSummarizerApp()
        
        # Mock the copy button click
        with patch('streamlit.button', return_value=True):
            # This would normally be called when copy button is clicked
            clipboard_text = app.output_handler.format_summary_for_clipboard(sample_summary_result)
            
            # Verify the formatted text is correct
            assert "test_contract.pdf" in clipboard_text
            assert sample_summary_result.summary_text in clipboard_text
    
    def test_streamlit_pdf_download_integration(self, mock_streamlit, sample_summary_result):
        """Test integration of PDF download with Streamlit interface."""
        from app import LegalDocumentSummarizerApp
        
        app = LegalDocumentSummarizerApp()
        
        # Test PDF download handling
        with patch('streamlit.button', return_value=True):
            try:
                app.handle_pdf_download(sample_summary_result)
                # Should call success if PDF generation works
                mock_streamlit['success'].assert_called()
            except Exception:
                # Should call error if PDF generation fails
                mock_streamlit['error'].assert_called()
    
    @pytest.fixture
    def sample_summary_result(self):
        """Create a sample SummaryResult for testing."""
        return SummaryResult(
            original_filename="test_contract.pdf",
            summary_text="This is a comprehensive legal contract between Party A and Party B.",
            processing_time=2.5,
            word_count=45,
            confidence_score=0.87,
            generated_at=datetime(2024, 1, 15, 14, 30, 0)
        )